# coding: utf-8

"""
    Apteco API

    An API to allow access to Apteco Marketing Suite resources  # noqa: E501

    The version of the OpenAPI document: v2
    Contact: support@apteco.com
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from apteco_api.configuration import Configuration


class DateRule(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'pattern_frequency': 'str',
        'pattern_interval': 'int',
        'pattern_type': 'str',
        'pattern_days_of_week': 'list[str]',
        'pattern_day_of_month': 'int',
        'pattern_month_of_year': 'int',
        'pattern_occurrence_of_day_in_month': 'str',
        'start_range_limit': 'str',
        'range_start_date': 'datetime',
        'start_range_relative': 'str',
        'start_range_offset_direction': 'str',
        'start_range_offset': 'int',
        'start_range_offset_units': 'str',
        'end_range_limit': 'str',
        'range_end_date': 'datetime',
        'end_range_relative': 'str',
        'end_range_offset_direction': 'str',
        'end_range_offset': 'int',
        'end_range_offset_units': 'str',
        'range_max_occurrences': 'int'
    }

    attribute_map = {
        'pattern_frequency': 'patternFrequency',
        'pattern_interval': 'patternInterval',
        'pattern_type': 'patternType',
        'pattern_days_of_week': 'patternDaysOfWeek',
        'pattern_day_of_month': 'patternDayOfMonth',
        'pattern_month_of_year': 'patternMonthOfYear',
        'pattern_occurrence_of_day_in_month': 'patternOccurrenceOfDayInMonth',
        'start_range_limit': 'startRangeLimit',
        'range_start_date': 'rangeStartDate',
        'start_range_relative': 'startRangeRelative',
        'start_range_offset_direction': 'startRangeOffsetDirection',
        'start_range_offset': 'startRangeOffset',
        'start_range_offset_units': 'startRangeOffsetUnits',
        'end_range_limit': 'endRangeLimit',
        'range_end_date': 'rangeEndDate',
        'end_range_relative': 'endRangeRelative',
        'end_range_offset_direction': 'endRangeOffsetDirection',
        'end_range_offset': 'endRangeOffset',
        'end_range_offset_units': 'endRangeOffsetUnits',
        'range_max_occurrences': 'rangeMaxOccurrences'
    }

    def __init__(self, pattern_frequency=None, pattern_interval=None, pattern_type=None, pattern_days_of_week=None, pattern_day_of_month=None, pattern_month_of_year=None, pattern_occurrence_of_day_in_month=None, start_range_limit=None, range_start_date=None, start_range_relative=None, start_range_offset_direction=None, start_range_offset=None, start_range_offset_units=None, end_range_limit=None, range_end_date=None, end_range_relative=None, end_range_offset_direction=None, end_range_offset=None, end_range_offset_units=None, range_max_occurrences=None, local_vars_configuration=None):  # noqa: E501
        """DateRule - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._pattern_frequency = None
        self._pattern_interval = None
        self._pattern_type = None
        self._pattern_days_of_week = None
        self._pattern_day_of_month = None
        self._pattern_month_of_year = None
        self._pattern_occurrence_of_day_in_month = None
        self._start_range_limit = None
        self._range_start_date = None
        self._start_range_relative = None
        self._start_range_offset_direction = None
        self._start_range_offset = None
        self._start_range_offset_units = None
        self._end_range_limit = None
        self._range_end_date = None
        self._end_range_relative = None
        self._end_range_offset_direction = None
        self._end_range_offset = None
        self._end_range_offset_units = None
        self._range_max_occurrences = None
        self.discriminator = None

        if pattern_frequency is not None:
            self.pattern_frequency = pattern_frequency
        if pattern_interval is not None:
            self.pattern_interval = pattern_interval
        if pattern_type is not None:
            self.pattern_type = pattern_type
        if pattern_days_of_week is not None:
            self.pattern_days_of_week = pattern_days_of_week
        if pattern_day_of_month is not None:
            self.pattern_day_of_month = pattern_day_of_month
        if pattern_month_of_year is not None:
            self.pattern_month_of_year = pattern_month_of_year
        if pattern_occurrence_of_day_in_month is not None:
            self.pattern_occurrence_of_day_in_month = pattern_occurrence_of_day_in_month
        if start_range_limit is not None:
            self.start_range_limit = start_range_limit
        if range_start_date is not None:
            self.range_start_date = range_start_date
        if start_range_relative is not None:
            self.start_range_relative = start_range_relative
        if start_range_offset_direction is not None:
            self.start_range_offset_direction = start_range_offset_direction
        if start_range_offset is not None:
            self.start_range_offset = start_range_offset
        if start_range_offset_units is not None:
            self.start_range_offset_units = start_range_offset_units
        if end_range_limit is not None:
            self.end_range_limit = end_range_limit
        if range_end_date is not None:
            self.range_end_date = range_end_date
        if end_range_relative is not None:
            self.end_range_relative = end_range_relative
        if end_range_offset_direction is not None:
            self.end_range_offset_direction = end_range_offset_direction
        if end_range_offset is not None:
            self.end_range_offset = end_range_offset
        if end_range_offset_units is not None:
            self.end_range_offset_units = end_range_offset_units
        if range_max_occurrences is not None:
            self.range_max_occurrences = range_max_occurrences

    @property
    def pattern_frequency(self):
        """Gets the pattern_frequency of this DateRule.  # noqa: E501


        :return: The pattern_frequency of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._pattern_frequency

    @pattern_frequency.setter
    def pattern_frequency(self, pattern_frequency):
        """Sets the pattern_frequency of this DateRule.


        :param pattern_frequency: The pattern_frequency of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Daily", "Weekly", "Monthly", "Yearly"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and pattern_frequency not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `pattern_frequency` ({0}), must be one of {1}"  # noqa: E501
                .format(pattern_frequency, allowed_values)
            )

        self._pattern_frequency = pattern_frequency

    @property
    def pattern_interval(self):
        """Gets the pattern_interval of this DateRule.  # noqa: E501


        :return: The pattern_interval of this DateRule.  # noqa: E501
        :rtype: int
        """
        return self._pattern_interval

    @pattern_interval.setter
    def pattern_interval(self, pattern_interval):
        """Sets the pattern_interval of this DateRule.


        :param pattern_interval: The pattern_interval of this DateRule.  # noqa: E501
        :type: int
        """

        self._pattern_interval = pattern_interval

    @property
    def pattern_type(self):
        """Gets the pattern_type of this DateRule.  # noqa: E501


        :return: The pattern_type of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._pattern_type

    @pattern_type.setter
    def pattern_type(self, pattern_type):
        """Sets the pattern_type of this DateRule.


        :param pattern_type: The pattern_type of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["CalculatedDay", "CalculatedMonth", "CalculatedYear", "Explicit"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and pattern_type not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `pattern_type` ({0}), must be one of {1}"  # noqa: E501
                .format(pattern_type, allowed_values)
            )

        self._pattern_type = pattern_type

    @property
    def pattern_days_of_week(self):
        """Gets the pattern_days_of_week of this DateRule.  # noqa: E501


        :return: The pattern_days_of_week of this DateRule.  # noqa: E501
        :rtype: list[str]
        """
        return self._pattern_days_of_week

    @pattern_days_of_week.setter
    def pattern_days_of_week(self, pattern_days_of_week):
        """Sets the pattern_days_of_week of this DateRule.


        :param pattern_days_of_week: The pattern_days_of_week of this DateRule.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["None", "All", "AllWeekdays", "AllWeekendDays", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                not set(pattern_days_of_week).issubset(set(allowed_values))):  # noqa: E501
            raise ValueError(
                "Invalid values for `pattern_days_of_week` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(pattern_days_of_week) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._pattern_days_of_week = pattern_days_of_week

    @property
    def pattern_day_of_month(self):
        """Gets the pattern_day_of_month of this DateRule.  # noqa: E501


        :return: The pattern_day_of_month of this DateRule.  # noqa: E501
        :rtype: int
        """
        return self._pattern_day_of_month

    @pattern_day_of_month.setter
    def pattern_day_of_month(self, pattern_day_of_month):
        """Sets the pattern_day_of_month of this DateRule.


        :param pattern_day_of_month: The pattern_day_of_month of this DateRule.  # noqa: E501
        :type: int
        """

        self._pattern_day_of_month = pattern_day_of_month

    @property
    def pattern_month_of_year(self):
        """Gets the pattern_month_of_year of this DateRule.  # noqa: E501


        :return: The pattern_month_of_year of this DateRule.  # noqa: E501
        :rtype: int
        """
        return self._pattern_month_of_year

    @pattern_month_of_year.setter
    def pattern_month_of_year(self, pattern_month_of_year):
        """Sets the pattern_month_of_year of this DateRule.


        :param pattern_month_of_year: The pattern_month_of_year of this DateRule.  # noqa: E501
        :type: int
        """

        self._pattern_month_of_year = pattern_month_of_year

    @property
    def pattern_occurrence_of_day_in_month(self):
        """Gets the pattern_occurrence_of_day_in_month of this DateRule.  # noqa: E501


        :return: The pattern_occurrence_of_day_in_month of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._pattern_occurrence_of_day_in_month

    @pattern_occurrence_of_day_in_month.setter
    def pattern_occurrence_of_day_in_month(self, pattern_occurrence_of_day_in_month):
        """Sets the pattern_occurrence_of_day_in_month of this DateRule.


        :param pattern_occurrence_of_day_in_month: The pattern_occurrence_of_day_in_month of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["None", "First", "Second", "Third", "Fourth", "Last"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and pattern_occurrence_of_day_in_month not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `pattern_occurrence_of_day_in_month` ({0}), must be one of {1}"  # noqa: E501
                .format(pattern_occurrence_of_day_in_month, allowed_values)
            )

        self._pattern_occurrence_of_day_in_month = pattern_occurrence_of_day_in_month

    @property
    def start_range_limit(self):
        """Gets the start_range_limit of this DateRule.  # noqa: E501


        :return: The start_range_limit of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._start_range_limit

    @start_range_limit.setter
    def start_range_limit(self, start_range_limit):
        """Sets the start_range_limit of this DateRule.


        :param start_range_limit: The start_range_limit of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Earliest", "Latest", "Actual", "Relative"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and start_range_limit not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `start_range_limit` ({0}), must be one of {1}"  # noqa: E501
                .format(start_range_limit, allowed_values)
            )

        self._start_range_limit = start_range_limit

    @property
    def range_start_date(self):
        """Gets the range_start_date of this DateRule.  # noqa: E501


        :return: The range_start_date of this DateRule.  # noqa: E501
        :rtype: datetime
        """
        return self._range_start_date

    @range_start_date.setter
    def range_start_date(self, range_start_date):
        """Sets the range_start_date of this DateRule.


        :param range_start_date: The range_start_date of this DateRule.  # noqa: E501
        :type: datetime
        """

        self._range_start_date = range_start_date

    @property
    def start_range_relative(self):
        """Gets the start_range_relative of this DateRule.  # noqa: E501


        :return: The start_range_relative of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._start_range_relative

    @start_range_relative.setter
    def start_range_relative(self, start_range_relative):
        """Sets the start_range_relative of this DateRule.


        :param start_range_relative: The start_range_relative of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Today", "Tomorrow", "Yesterday", "ThisWeek", "ThisMonth", "ThisQuarter", "ThisYear", "ThisBusinessMonth", "ThisBusinessQuarter", "ThisBusinessYear", "LoadDate", "LoadWeek", "LoadMonth", "LoadQuarter", "LoadYear", "FirstPopulatedDate", "FirstPopulatedWeek", "FirstPopulatedMonth", "FirstPopulatedQuarter", "FirstPopulatedYear", "LastPopulatedDate", "LastPopulatedWeek", "LastPopulatedMonth", "LastPopulatedQuarter", "LastPopulatedYear", "CustomDate"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and start_range_relative not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `start_range_relative` ({0}), must be one of {1}"  # noqa: E501
                .format(start_range_relative, allowed_values)
            )

        self._start_range_relative = start_range_relative

    @property
    def start_range_offset_direction(self):
        """Gets the start_range_offset_direction of this DateRule.  # noqa: E501


        :return: The start_range_offset_direction of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._start_range_offset_direction

    @start_range_offset_direction.setter
    def start_range_offset_direction(self, start_range_offset_direction):
        """Sets the start_range_offset_direction of this DateRule.


        :param start_range_offset_direction: The start_range_offset_direction of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Forward", "Backward"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and start_range_offset_direction not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `start_range_offset_direction` ({0}), must be one of {1}"  # noqa: E501
                .format(start_range_offset_direction, allowed_values)
            )

        self._start_range_offset_direction = start_range_offset_direction

    @property
    def start_range_offset(self):
        """Gets the start_range_offset of this DateRule.  # noqa: E501


        :return: The start_range_offset of this DateRule.  # noqa: E501
        :rtype: int
        """
        return self._start_range_offset

    @start_range_offset.setter
    def start_range_offset(self, start_range_offset):
        """Sets the start_range_offset of this DateRule.


        :param start_range_offset: The start_range_offset of this DateRule.  # noqa: E501
        :type: int
        """

        self._start_range_offset = start_range_offset

    @property
    def start_range_offset_units(self):
        """Gets the start_range_offset_units of this DateRule.  # noqa: E501


        :return: The start_range_offset_units of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._start_range_offset_units

    @start_range_offset_units.setter
    def start_range_offset_units(self, start_range_offset_units):
        """Sets the start_range_offset_units of this DateRule.


        :param start_range_offset_units: The start_range_offset_units of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Days", "Weeks", "Months", "Quarters", "Years"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and start_range_offset_units not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `start_range_offset_units` ({0}), must be one of {1}"  # noqa: E501
                .format(start_range_offset_units, allowed_values)
            )

        self._start_range_offset_units = start_range_offset_units

    @property
    def end_range_limit(self):
        """Gets the end_range_limit of this DateRule.  # noqa: E501


        :return: The end_range_limit of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._end_range_limit

    @end_range_limit.setter
    def end_range_limit(self, end_range_limit):
        """Sets the end_range_limit of this DateRule.


        :param end_range_limit: The end_range_limit of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Earliest", "Latest", "Actual", "Forward", "Backward", "Relative"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and end_range_limit not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `end_range_limit` ({0}), must be one of {1}"  # noqa: E501
                .format(end_range_limit, allowed_values)
            )

        self._end_range_limit = end_range_limit

    @property
    def range_end_date(self):
        """Gets the range_end_date of this DateRule.  # noqa: E501


        :return: The range_end_date of this DateRule.  # noqa: E501
        :rtype: datetime
        """
        return self._range_end_date

    @range_end_date.setter
    def range_end_date(self, range_end_date):
        """Sets the range_end_date of this DateRule.


        :param range_end_date: The range_end_date of this DateRule.  # noqa: E501
        :type: datetime
        """

        self._range_end_date = range_end_date

    @property
    def end_range_relative(self):
        """Gets the end_range_relative of this DateRule.  # noqa: E501


        :return: The end_range_relative of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._end_range_relative

    @end_range_relative.setter
    def end_range_relative(self, end_range_relative):
        """Sets the end_range_relative of this DateRule.


        :param end_range_relative: The end_range_relative of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Today", "Tomorrow", "Yesterday", "ThisWeek", "ThisMonth", "ThisQuarter", "ThisYear", "ThisBusinessMonth", "ThisBusinessQuarter", "ThisBusinessYear", "LoadDate", "LoadWeek", "LoadMonth", "LoadQuarter", "LoadYear", "FirstPopulatedDate", "FirstPopulatedWeek", "FirstPopulatedMonth", "FirstPopulatedQuarter", "FirstPopulatedYear", "LastPopulatedDate", "LastPopulatedWeek", "LastPopulatedMonth", "LastPopulatedQuarter", "LastPopulatedYear", "CustomDate"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and end_range_relative not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `end_range_relative` ({0}), must be one of {1}"  # noqa: E501
                .format(end_range_relative, allowed_values)
            )

        self._end_range_relative = end_range_relative

    @property
    def end_range_offset_direction(self):
        """Gets the end_range_offset_direction of this DateRule.  # noqa: E501


        :return: The end_range_offset_direction of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._end_range_offset_direction

    @end_range_offset_direction.setter
    def end_range_offset_direction(self, end_range_offset_direction):
        """Sets the end_range_offset_direction of this DateRule.


        :param end_range_offset_direction: The end_range_offset_direction of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Forward", "Backward"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and end_range_offset_direction not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `end_range_offset_direction` ({0}), must be one of {1}"  # noqa: E501
                .format(end_range_offset_direction, allowed_values)
            )

        self._end_range_offset_direction = end_range_offset_direction

    @property
    def end_range_offset(self):
        """Gets the end_range_offset of this DateRule.  # noqa: E501


        :return: The end_range_offset of this DateRule.  # noqa: E501
        :rtype: int
        """
        return self._end_range_offset

    @end_range_offset.setter
    def end_range_offset(self, end_range_offset):
        """Sets the end_range_offset of this DateRule.


        :param end_range_offset: The end_range_offset of this DateRule.  # noqa: E501
        :type: int
        """

        self._end_range_offset = end_range_offset

    @property
    def end_range_offset_units(self):
        """Gets the end_range_offset_units of this DateRule.  # noqa: E501


        :return: The end_range_offset_units of this DateRule.  # noqa: E501
        :rtype: str
        """
        return self._end_range_offset_units

    @end_range_offset_units.setter
    def end_range_offset_units(self, end_range_offset_units):
        """Sets the end_range_offset_units of this DateRule.


        :param end_range_offset_units: The end_range_offset_units of this DateRule.  # noqa: E501
        :type: str
        """
        allowed_values = ["Days", "Weeks", "Months", "Quarters", "Years"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and end_range_offset_units not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `end_range_offset_units` ({0}), must be one of {1}"  # noqa: E501
                .format(end_range_offset_units, allowed_values)
            )

        self._end_range_offset_units = end_range_offset_units

    @property
    def range_max_occurrences(self):
        """Gets the range_max_occurrences of this DateRule.  # noqa: E501


        :return: The range_max_occurrences of this DateRule.  # noqa: E501
        :rtype: int
        """
        return self._range_max_occurrences

    @range_max_occurrences.setter
    def range_max_occurrences(self, range_max_occurrences):
        """Sets the range_max_occurrences of this DateRule.


        :param range_max_occurrences: The range_max_occurrences of this DateRule.  # noqa: E501
        :type: int
        """

        self._range_max_occurrences = range_max_occurrences

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DateRule):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, DateRule):
            return True

        return self.to_dict() != other.to_dict()
